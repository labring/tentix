import { type JSONContentZod } from "tentix-server/types";
import { Loader2Icon, UploadIcon, LibraryBigIcon, XIcon } from "lucide-react";
import React, { useRef, useState, useCallback, useMemo } from "react";
import {
  SendIcon,
  Button,
  StaffChatEditor,
  useToast,
  type EditorRef,
} from "tentix-ui";
import { processFilesAndUpload } from "../upload-utils";
import { useChatStore } from "@store/index";
import useLocalUser from "@hook/use-local-user.tsx";
import { collectFavoritedKnowledge } from "@lib/query";
import { useTranslation } from "i18n";

// ÈîôËØØÂ§ÑÁêÜÂ∑•ÂÖ∑ÂáΩÊï∞
const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) {
    return error.message;
  }
  if (typeof error === "string") {
    return error;
  }
  if (error && typeof error === "object" && "message" in error) {
    return String(error.message);
  }
  return "ÂèëÈÄÅÊ∂àÊÅØÊó∂Âá∫Áé∞Êú™Áü•ÈîôËØØ";
};

// ‰∏ä‰º†ËøõÂ∫¶Êé•Âè£
interface UploadProgress {
  uploaded: number;
  total: number;
  currentFile?: string;
}

// ÁªÑ‰ª∂ Props Êé•Âè£
interface MessageInputProps {
  onSendMessage: (
    content: JSONContentZod,
    isInternal?: boolean,
  ) => Promise<void>;
  onTyping?: () => void;
  isLoading: boolean;
}

// Êñá‰ª∂ÁªüËÆ°ÁªìÊûúÊé•Âè£
interface FileStats {
  hasFiles: boolean;
  count: number;
}

// Ê£ÄÊü•ÂÜÖÂÆπËäÇÁÇπÊòØÂê¶‰∏∫Êú¨Âú∞Êñá‰ª∂
const isLocalFileNode = (
  node: { type?: string; attrs?: { isLocalFile?: boolean } } | unknown,
): boolean => {
  if (!node || typeof node !== "object") return false;
  const n = node as { type?: string; attrs?: { isLocalFile?: boolean } };
  return n.type === "image" && n.attrs?.isLocalFile === true;
};

// Ê£ÄÊü•ÂÜÖÂÆπËäÇÁÇπÊòØÂê¶ÊúâÂÆûÈôÖÂÜÖÂÆπ - ÊîØÊåÅÊâÄÊúâTipTapËäÇÁÇπÁ±ªÂûã
const hasNodeContent = (
  node: { type?: string; content?: unknown[]; text?: string } | unknown,
): boolean => {
  if (!node || typeof node !== "object") return false;
  const n = node as { type?: string; content?: unknown[]; text?: string };

  if (!n.type) return false;

  // ÊÆµËêΩÔºöÊ£ÄÊü•ÊòØÂê¶ÊúâÂÜÖÂÆπ
  if (n.type === "paragraph" && Array.isArray(n.content)) {
    return n.content.length > 0;
  }

  // Ê†áÈ¢òÔºöÊúâÂÜÖÂÆπÂ∞±ÁÆóÊúâÊïàÔºàÊîØÊåÅh1-h6Ôºâ
  if (n.type === "heading" && Array.isArray(n.content)) {
    return n.content.length > 0;
  }

  // ÂàóË°®ÔºöÊúâÂàóË°®È°πÂ∞±ÁÆóÊúâÊïà
  if (
    (n.type === "orderedList" || n.type === "bulletList") &&
    Array.isArray(n.content)
  ) {
    return n.content.length > 0;
  }

  // ÂàóË°®È°πÔºöÊúâÂÜÖÂÆπÂ∞±ÁÆóÊúâÊïà
  if (n.type === "listItem" && Array.isArray(n.content)) {
    return n.content.length > 0;
  }

  // ÂºïÁî®ÂùóÔºöÊúâÂÜÖÂÆπÂ∞±ÁÆóÊúâÊïà
  if (n.type === "blockquote" && Array.isArray(n.content)) {
    return n.content.length > 0;
  }

  // ‰ª£Á†ÅÂùóÔºöÁõ¥Êé•ÁÆó‰ΩúÊúâÂÜÖÂÆπÔºàÂç≥‰ΩøÁ©∫ÁöÑ‰πüÂèØ‰ª•ÂèëÈÄÅÔºâ
  if (n.type === "codeBlock") {
    return true;
  }

  // Ê∞¥Âπ≥Á∫øÔºöÁõ¥Êé•ÁÆó‰ΩúÊúâÂÜÖÂÆπ
  if (n.type === "horizontalRule") {
    return true;
  }

  // ÂõæÁâáÂíåÂ™í‰ΩìÊñá‰ª∂ÔºöÁõ¥Êé•ÁÆó‰ΩúÊúâÂÜÖÂÆπ
  if (n.type === "image") {
    return true;
  }

  // Á°¨Êç¢Ë°åÔºöÁõ¥Êé•ÁÆó‰ΩúÊúâÂÜÖÂÆπ
  if (n.type === "hardBreak") {
    return true;
  }

  // ÊñáÊú¨ËäÇÁÇπÔºöÊ£ÄÊü•ÊòØÂê¶ÊúâÊñáÊú¨ÂÜÖÂÆπ
  if (n.type === "text" && n.text) {
    return n.text.trim().length > 0;
  }

  return false;
};

export function StaffMessageInput({
  onSendMessage,
  onTyping,
  isLoading,
}: MessageInputProps) {
  const { t } = useTranslation();
  const [newMessage, setNewMessage] = useState<JSONContentZod>({
    type: "doc",
    content: [],
  });
  const [uploadProgress, setUploadProgress] = useState<UploadProgress | null>(
    null,
  );

  const editorRef = useRef<EditorRef>(null);
  const { toast } = useToast();
  const { kbSelectionMode, clearKbSelection, selectedMessageIds } =
    useChatStore();
  const { id: userId } = useLocalUser();

  // ÂàÜÊûêÊ∂àÊÅØÂÜÖÂÆπ‰∏≠ÁöÑÊñá‰ª∂ÊÉÖÂÜµ
  const analyzeFileContent = useCallback(
    (content: JSONContentZod): FileStats => {
      let count = 0;
      let hasFiles = false;

      const analyzeNode = (node: unknown): void => {
        if (isLocalFileNode(node)) {
          count++;
          hasFiles = true;
        }
        if (
          node &&
          typeof node === "object" &&
          Array.isArray((node as { content?: unknown[] }).content)
        ) {
          (node as { content?: unknown[] }).content!.forEach(analyzeNode);
        }
      };

      content.content?.forEach(analyzeNode);

      return { hasFiles, count };
    },
    [],
  );

  // ‰ΩøÁî® useMemo ‰ºòÂåñÊñá‰ª∂ÁªüËÆ°ËÆ°ÁÆó
  const fileStats = useMemo(
    () => analyzeFileContent(newMessage),
    [newMessage, analyzeFileContent],
  );

  // Ê£ÄÊü•Ê∂àÊÅØÊòØÂê¶ÊúâÂÆûÈôÖÂÜÖÂÆπÂèØÂèëÈÄÅ
  const hasMessageContent = useMemo(() => {
    return newMessage?.content?.some(hasNodeContent) || false;
  }, [newMessage]);

  // ÊòæÁ§∫ÈîôËØØÊèêÁ§∫
  const showErrorToast = useCallback(
    (error: unknown) => {
      const message = getErrorMessage(error);
      toast({
        title: t("send_failed"),
        description: message,
        variant: "destructive",
      });
    },
    [toast, t],
  );

  // Ê∏ÖÁ©∫ÁºñËæëÂô®ÂíåÊ∂àÊÅØÁä∂ÊÄÅ
  const clearEditor = useCallback(() => {
    editorRef.current?.clearContent();
    setNewMessage({
      type: "doc",
      content: [],
    });
  }, []);

  // Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†ÊµÅÁ®ã
  const handleFileUpload = useCallback(
    async (content: JSONContentZod): Promise<JSONContentZod> => {
      const { processedContent } = await processFilesAndUpload(
        content,
        (progress) => setUploadProgress(progress),
      );

      setUploadProgress(null);

      return processedContent;
    },
    [],
  );

  // Â§ÑÁêÜÊ∂àÊÅØÊèê‰∫§
  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      e?.preventDefault();

      if (!newMessage || isLoading || !hasMessageContent) {
        return;
      }

      try {
        let contentToSend = newMessage;

        // Â¶ÇÊûúÊúâÊñá‰ª∂ÈúÄË¶Å‰∏ä‰º†ÔºåÂÖàÂ§ÑÁêÜ‰∏ä‰º†
        if (fileStats.hasFiles) {
          contentToSend = await handleFileUpload(newMessage);
        }

        // Á≠âÂæÖÊ∂àÊÅØÂèëÈÄÅÂÆåÊàê
        await onSendMessage(contentToSend, editorRef.current?.isInternal);

        // Âè™ÊúâÂèëÈÄÅÊàêÂäüÂêéÊâçÊ∏ÖÁêÜÁºñËæëÂô®
        clearEditor();
      } catch (error) {
        console.error("ÂèëÈÄÅÊ∂àÊÅØÂ§±Ë¥•:", error);
        setUploadProgress(null);
        showErrorToast(error);

        // ÂèëÈÄÅÂ§±Ë¥•Êó∂‰∏çÊ∏ÖÁêÜÁºñËæëÂô®ÔºåËÆ©Áî®Êà∑ÂèØ‰ª•ÈáçËØï
        // ÁºñËæëÂô®ÂÜÖÂÆπ‰øùÊåÅ‰∏çÂèòÔºåÁî®Êà∑ÂèØ‰ª•ÂÜçÊ¨°Â∞ùËØïÂèëÈÄÅ
      }
    },
    [
      newMessage,
      isLoading,
      hasMessageContent,
      fileStats,
      handleFileUpload,
      onSendMessage,
      clearEditor,
      showErrorToast,
    ],
  );

  const editorProps = useMemo(
    () => ({
      handleKeyDown: (_: unknown, event: KeyboardEvent) => {
        // üî• Enter ÈîÆ -> ÂèëÈÄÅÊ∂àÊÅØ
        if (
          event.key === "Enter" &&
          !event.shiftKey &&
          !event.metaKey &&
          !event.ctrlKey
        ) {
          event.preventDefault();
          handleSubmit();
          return true; // ÂëäËØâ TipTap ‰∫ã‰ª∂Â∑≤Â§ÑÁêÜ
        }
        return false; // ËÆ© TipTap ÁªßÁª≠Â§ÑÁêÜÂÖ∂‰ªñÊåâÈîÆ
      },
    }),
    [handleSubmit],
  );

  // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÂèëÈÄÅÊ∂àÊÅØ
  const canSend = useMemo(() => {
    return !isLoading && !uploadProgress && hasMessageContent;
  }, [isLoading, uploadProgress, hasMessageContent]);

  // ËÆ°ÁÆó‰∏ä‰º†ËøõÂ∫¶Êù°È´òÂ∫¶ÔºàÁî®‰∫éÂä®ÊÄÅË∞ÉÊï¥Â∏ÉÂ±ÄÔºâ
  const progressBarHeight = uploadProgress ? 60 : 0; // Ê†πÊçÆÂÆûÈôÖÈ´òÂ∫¶Ë∞ÉÊï¥

  // Ê∏≤Êüì‰∏ä‰º†ËøõÂ∫¶Êù°
  const renderUploadProgress = () => {
    if (!uploadProgress) return null;

    const progressPercent = Math.round(
      (uploadProgress.uploaded / uploadProgress.total) * 100,
    );

    return (
      <div className="absolute top-0 left-0 right-0 bg-zinc-100 px-4 py-2 border-b z-10">
        <div className="flex items-center justify-between text-sm">
          <div className="flex items-center gap-2">
            <UploadIcon className="h-4 w-4 animate-pulse text-zinc-600" />
            <span className="text-zinc-600">
              {t("uploading_simple", {
                uploaded: uploadProgress.uploaded,
                total: uploadProgress.total,
              })}
              {uploadProgress.currentFile && ` - ${uploadProgress.currentFile}`}
            </span>
          </div>
          <div className="text-zinc-600">{progressPercent}%</div>
        </div>
        <div className="mt-1 bg-zinc-200 rounded-full h-1">
          <div
            className="bg-zinc-600 h-1 rounded-full transition-all duration-300"
            style={{ width: `${progressPercent}%` }}
          />
        </div>
      </div>
    );
  };

  // Ê∏≤ÊüìÂèëÈÄÅÊåâÈíÆÂÜÖÂÆπ
  const renderSendButtonContent = () => {
    if (isLoading || uploadProgress) {
      return <Loader2Icon className="!h-5 !w-5 animate-spin" />;
    }

    return <SendIcon className="!h-5 !w-5" />;
  };

  const isUploading = uploadProgress !== null;

  if (kbSelectionMode) {
    const count = selectedMessageIds.size;
    const handleCollect = async () => {
      try {
        const { currentTicketId } = useChatStore.getState();
        if (!currentTicketId) return;
        const res = await collectFavoritedKnowledge({
          ticketId: currentTicketId,
          messageIds: Array.from(selectedMessageIds),
          favoritedBy: userId,
        });
        if (res.success) {
          toast({ title: "ÊàêÂäü", description: "Â∑≤Êî∂ÂΩïÂà∞Áü•ËØÜÂ∫ì" });
          clearKbSelection();
        } else {
          toast({
            title: "Â§±Ë¥•",
            description: res.message,
            variant: "destructive",
          });
        }
      } catch (error) {
        const message = getErrorMessage(error);
        toast({ title: "Â§±Ë¥•", description: message, variant: "destructive" });
      }
    };
    return (
      <div className="border-t relative">
        <div className="flex items-center py-3 px-6">
          <div className="text-sm text-zinc-500 font-sans font-normal leading-normal">
            {t("selected_count", { count })}
          </div>
          <div className="flex-1 flex items-center justify-center">
            <Button
              variant="outline"
              onClick={handleCollect}
              className="flex px-3 py-2 gap-2"
              disabled={count === 0}
            >
              <LibraryBigIcon
                className="!h-4 !w-4 text-zinc-500"
                strokeWidth={1.33}
              />
              <span className="text-sm text-zinc-900 font-sans font-medium leading-normal">
                {t("klg_base")}
              </span>
            </Button>
          </div>
          <Button
            variant="ghost"
            onClick={() => {
              clearKbSelection();
              useChatStore.getState().setKbSelectionMode(false);
            }}
            className="flex items-center justify-center h-8 w-8"
          >
            <XIcon
              className="!h-5 !w-5 text-zinc-500"
              strokeWidth={1.5}
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="border-t relative">
      {/* ‰∏ä‰º†ËøõÂ∫¶ÊåáÁ§∫Âô® */}
      {renderUploadProgress()}

      {/* ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü - Âä®ÊÄÅË∞ÉÊï¥È°∂ÈÉ®Èó¥Ë∑ù */}
      <form
        onSubmit={handleSubmit}
        style={{
          marginTop: progressBarHeight,
          transition: "margin-top 0.3s ease-in-out",
        }}
      >
        <div className="flex">
          <StaffChatEditor
            ref={editorRef}
            value={newMessage}
            onChange={(value) => {
              onTyping?.();
              setNewMessage(value as JSONContentZod);
            }}
            throttleDelay={500}
            editorContentClassName="overflow-auto h-full"
            editable={!isUploading}
            editorClassName="focus:outline-none p-4 h-full"
            className="border-none"
            editorProps={editorProps}
          />
        </div>

        <Button
          type="submit"
          size="icon"
          className="absolute right-3 bottom-4 flex justify-center items-center rounded-[10px] bg-zinc-900 z-20 h-9 w-9"
          disabled={!canSend}
        >
          {renderSendButtonContent()}
          <span className="sr-only">{t("send_message_shortcut")}</span>
        </Button>
      </form>
    </div>
  );
}
